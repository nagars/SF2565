/*
 * class_def.hpp
 *
 *  Created on: Nov 12, 2024
 *      Author: Shawn / Alessio
 */

#ifndef CLASS_DEF_HPP_
#define CLASS_DEF_HPP_

#include <cmath>
#include <vector>
#include <memory>
#include <cassert>
#include <limits>

#include "Eigen/Eigen"


#define EPSILON std::numeric_limits<double>::epsilon()

// Holds an x,y point
class Point {
public:
	// Default Constructor
	Point();
	// Parameter Constructor
	Point(const double xCoord, const double yCoord)
	: x(xCoord), y(yCoord){}
	// Coordinate variables
	double x, y;

private:
protected:
};

// Used to represent the bottom curve
class Curve {
public:
	virtual ~Curve() = default;
	virtual Point at(double t) const = 0;
private:
protected:
};

// Used to represent the line boundaries of the top/left/right
// Used to represent the line boundaries of the top/left/right
class StraightLine : public Curve {

public:
	StraightLine(Point a, Point b):
		pointStart(a), pointEnd(b){}

	// t = {0,1}. t = 0 -> pointStart. t = 1 -> pointEnd
	Point at(double t) const override{
		// Edge case for vertical line
		if(fabs(pointEnd.x - pointStart.x) < EPSILON){
			Point p_toGet(pointStart.x,0);	// Init y point as 0 for now
			p_toGet.y = pointStart.y + t*(pointEnd.y - pointStart.y);
			return p_toGet;
		}// Edge case for horizontal line
		else if (fabs(pointEnd.y - pointStart.y) < EPSILON){

			Point p_toGet(0,pointStart.y);	// Init x point as 0 for now
			p_toGet.x = pointStart.x + t*(pointEnd.x - pointStart.x);
			return p_toGet;
		} else {
			double pointOfInterest = pointStart.x + t*(pointEnd.x - pointStart.x);
			Point p_toGet(pointOfInterest,0);	// Init y point as 0 for now
			// p_toGet.y = pointStart.y + t*(pointEnd.x - pointStart.x);
			p_toGet.y = pointStart.y + t*(pointEnd.y - pointStart.y);
			return p_toGet;
		}
	}


	Point pointStart;		// Start of line
	Point pointEnd;			// End of line
};


//Class to hold the matrices of x and y coordinates generated by
//the Domain TFI method
class Grid {
public:
	// Constructor initializes grid with given dimensions
	Grid(int rows, int cols)
	: x(Eigen::MatrixXd::Zero(rows, cols)),
	  y(Eigen::MatrixXd::Zero(rows, cols))
	{ }

	// Getters for the x and y matrices
	const Eigen::MatrixXd& GetX() const { return x; }
	const Eigen::MatrixXd& GetY() const { return y; }

	// Setters for the x and y matrices
	void SetX(const Eigen::MatrixXd& newX) { x = newX; }
	void SetY(const Eigen::MatrixXd& newY) { y = newY; }

	// Access element in the grid
	void SetPoint(int row, int col,
			double xValue, double yValue) {
		x(row, col) = xValue;
		y(row, col) = yValue;
	}

private:
	Eigen::MatrixXd x; // Matrix holding x-coordinates
	Eigen::MatrixXd y; // Matrix holding y-coordinates

protected:
};


class Domain {
public:
	Domain(std::unique_ptr<Curve> bottom, std::unique_ptr<Curve> top, 
			std::unique_ptr<Curve> left, std::unique_ptr<Curve> right,
			int numDivisions)
	: bottom(std::move(bottom)), top(std::move(top)),
	  left(std::move(left)), right(std::move(right)),
	  grid(numDivisions + 1, numDivisions + 1)
	{ }

	// Grid-object generator
	// Generates the grid based on transfinite interpolation (TFI)
	void GenerateGrid() {
		int divisions = grid.GetX().rows() - 1; // `numDivisions` intervals
		for (int i = 0; i <= divisions; ++i) {
			double eta = static_cast<double>(i) / divisions;
			for (int j = 0; j <= divisions; ++j) {
				double xi = static_cast<double>(j) / divisions;

				// Use TFI to compute coordinates
				Point p = TFI(xi, eta);
				grid.SetPoint(i, j, p.x, p.y);
			}
		}
	}


	// Generates an x, y pair based on xi and eta using TFI
	// Based on 'Basic structured grid generation (Farrashkhalvat, Miles) 
	// section 4.3.2
	Point TFI(double xi, double eta) {
		// Use the boundary curves to compute the x, y coordinates
		// 
		auto [xBottom_atXi, yBottom_atXi] = bottom->at(xi);
		auto [xTop_atXi, yTop_atXi] = top->at(xi);
		auto [xRight_atEta, yRight_atEta] = right->at(eta);
		auto [xLeft_atEta, yLeft_atEta] = left->at(eta);
		auto [xBottom_atZero, yBottom_atZero] = bottom->at(0);
		auto [xTop_atZero, yTop_atZero] = top->at(0);
		auto [xBottom_atOne, yBottom_atOne] = bottom->at(1);
		auto [xTop_atOne, yTop_atOne] = top->at(1);

		double x = (1 - xi) * xLeft_atEta + xi * xRight_atEta
				+ (1 - eta) * xBottom_atXi + eta * xTop_atXi
				- (1 - xi) * (1 - eta) * xBottom_atZero
				- (1 - xi) * eta * xTop_atZero
				- (1 - eta) * xi * xBottom_atOne
				- xi * eta * xTop_atOne;

		double y = (1 - xi) * yLeft_atEta + xi * yRight_atEta
				+ (1 - eta) * yBottom_atXi + eta * yTop_atXi
				- (1 - xi) * (1 - eta) * yBottom_atZero
				- (1 - xi) * eta * yTop_atZero
				- (1 - eta) * xi * yBottom_atOne
				- xi * eta * yTop_atOne;

		return Point(x, y);
	}

	// Grid getter
	const Grid& GetGrid() const { return grid; }

private:
	std::unique_ptr <Curve> bottom;
	std::unique_ptr <Curve> top;
	std::unique_ptr <Curve> left;
	std::unique_ptr <Curve> right;
	Grid grid; // Grid that holds x and y coordinates
protected:
};


#endif /* CLASS_DEF_HPP_ */
