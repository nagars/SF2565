/*
 * class_def.hpp
 *
 *  Created on: Nov 12, 2024
 *      Author: Shawn / Alessio
 */

#ifndef CLASS_DEF_HPP_
#define CLASS_DEF_HPP_

#include <cmath>
#include <vector>
#include <memory>
#include <cassert>
#include <limits>
#include <iostream>

#include "Eigen/Eigen"
#include <boost/math/quadrature/trapezoidal.hpp>
#include <boost/math/differentiation/finite_difference.hpp>


// Holds an x,y point
class Point {

public:
	// Default Constructor
	// Point();
	Point() : x(0.0), y(0.0) {}
	// Parameter Constructor
	Point(const double xCoord, const double yCoord)
	: x(xCoord), y(yCoord){}
	// Coordinate variables
	double x, y;

private:

protected:
};


// Used to represent the bottom curve
class Curve {
public:
	virtual ~Curve() = default;
	virtual Point at(double t) const = 0;

private:

protected:
};


class EquationCurve:public Curve {

public:
	virtual~EquationCurve() = default;

	// Compute reparametized curve
	// Option to use point cache to compare peformance
	Point at(double t) const override;
	
	// Activate point cache for performance testing
	void enableCache(bool enable) {
		cacheEnabled = enable;
	}

private:
	// Compute arc-length function s(t) using boost numerical integration
	double arcLength(double t) const;

	virtual Point gamma(double t) const = 0;
	virtual Point gammaprime (double t) const = 0;

	const double TOL = 1e-12; // Tolerance for numerical calculations
	const uintmax_t MAX_ITER = 10000;	// Max iterations for newton method

	mutable double totalLength = 0.0; // Total curve arc length s(1)
	mutable bool totalLengthComputed = false; // Flag indicating s(1) already computed

	mutable std::unordered_map<double, Point> cache; // Cache of already computed points
	bool cacheEnabled = false; // point cache toggle status

protected:
	std::function<double(double)> eqFunc;
};


// Used to represent the line boundaries of the top/left/right
class StraightLine : public Curve {

public:
	StraightLine(Point a, Point b):
		pointStart(a), pointEnd(b) { }

	// t = {0,1}. t = 0 -> pointStart. t = 1 -> pointEnd
	Point at(double t) const override;

	Point pointStart;		// Start of line
	Point pointEnd;			// End of line

private:
	// Tolerance to check for edge cases of vertical boundaries
	static constexpr double EPSILON = std::numeric_limits<double>::epsilon();

protected:
};


class BottomCurve : public EquationCurve {

public:
	BottomCurve(std::function<double(double)> func) {
		eqFunc = func;		// Function defining curve
	}

	// Domain Function of curve
	double x_of_t(double t) const;

	// Returns P(t)
	Point gamma(double t) const override;

	// Calculates dP(t)/dt using finite differences
	Point gammaprime(double t) const override;

private:
protected:
};


//Class to hold the matrices of x and y coordinates generated by
//the Domain TFI method
class Grid {

public:
	// Constructor initializes grid with given dimensions
	Grid(int rows, int cols)
	: x(Eigen::MatrixXd::Zero(rows, cols)),
	  y(Eigen::MatrixXd::Zero(rows, cols))
	{ }

	// Getters for the x and y matrices
	const Eigen::MatrixXd& GetX() const { return x; }
	const Eigen::MatrixXd& GetY() const { return y; }

	// Setters for the x and y matrices
	void SetX(const Eigen::MatrixXd& newX) { x = newX; }
	void SetY(const Eigen::MatrixXd& newY) { y = newY; }

	// Access element in the grid
	void SetPoint(int row, int col,
			double xValue, double yValue) {
		x(row, col) = xValue;
		y(row, col) = yValue;
	}

private:
	Eigen::MatrixXd x; // Matrix holding x-coordinates
	Eigen::MatrixXd y; // Matrix holding y-coordinates

protected:
};


class Domain {

public:
	Domain(std::unique_ptr<Curve> bottom, std::unique_ptr<Curve> top, 
			std::unique_ptr<Curve> left, std::unique_ptr<Curve> right,
			int numDivisions)
	: bottom(std::move(bottom)), top(std::move(top)),
	  left(std::move(left)), right(std::move(right)),
	  grid(numDivisions + 1, numDivisions + 1)
	{ }

	// Grid-object generator
	// Generates the grid based on transfinite interpolation (TFI)
	void GenerateGrid();
	// Generates an x, y pair based on xi and eta using TFI
	// Based on 'Basic structured grid generation (Farrashkhalvat, Miles) 
	// section 4.3.2
	Point TFI(double xi, double eta);

	// Activate point cache of bottom boundary for performance testing
	void enableCache(bool enable) {
		auto* bottomBoundary = dynamic_cast<EquationCurve*>(bottom.get());
		bottomBoundary->enableCache(enable);
	}

	// Grid getter
	const Grid& GetGrid() const { return grid; }

private:
	std::unique_ptr <Curve> bottom;
	std::unique_ptr <Curve> top;
	std::unique_ptr <Curve> left;
	std::unique_ptr <Curve> right;
	Grid grid; // Grid that holds x and y coordinates

protected:
};


#endif /* CLASS_DEF_HPP_ */
