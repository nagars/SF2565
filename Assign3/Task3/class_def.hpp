/*
 * class_def.hpp
 *
 *  Created on: Nov 12, 2024
 *      Author: Shawn / Alessio
 */

#ifndef CLASS_DEF_HPP_
#define CLASS_DEF_HPP_

#include <cmath>
#include <vector>
#include <memory>
#include <cassert>
#include <limits>

#include "Eigen/Eigen"
// #include <boost/math/quadrature/trapezoidal.hpp>
// #include <boost/math/tools/roots.hpp>
#include <boost/math/differentiation/finite_difference.hpp>

#define EPSILON std::numeric_limits<double>::epsilon()
//#define DELTAX std::sqrt(EPSILON)
#define DELTAX 0.1

#define MAX_NEWTON_ITER			10000
#define MAX_NEWTON_THRESHOLD	1e-5

// Holds an x,y point
class Point {
public:
	// Default Constructor
	Point();
	// Parameter Constructor
	Point(const double xCoord, const double yCoord)
	: x(xCoord), y(yCoord){}
	// Coordinate variables
	double x, y;

private:
protected:
};

// Used to represent the bottom curve
class Curve {
public:
	virtual ~Curve() = default;
	virtual Point at(double t) const = 0;
private:
protected:
};

// Used to represent the line boundaries of the top/left/right
// Used to represent the line boundaries of the top/left/right
class StraightLine : public Curve {

public:
	StraightLine(Point a, Point b):
		pointStart(a), pointEnd(b){}

	// t = {0,1}. t = 0 -> pointStart. t = 1 -> pointEnd
	Point at(double t) const override{
		// Edge case for vertical line
		if(fabs(pointEnd.x - pointStart.x) < EPSILON){
			Point p_toGet(pointStart.x,0);	// Init y point as 0 for now
			p_toGet.y = pointStart.y + t*(pointEnd.y - pointStart.y);
			return p_toGet;
		}// Edge case for horizontal line
		else if (fabs(pointEnd.y - pointStart.y) < EPSILON){

			Point p_toGet(0,pointStart.y);	// Init x point as 0 for now
			p_toGet.x = pointStart.x + t*(pointEnd.x - pointStart.x);
			return p_toGet;
		} else {
			double pointOfInterest = pointStart.x + t*(pointEnd.x - pointStart.x);
			Point p_toGet(pointOfInterest,0);	// Init y point as 0 for now
			// p_toGet.y = pointStart.y + t*(pointEnd.x - pointStart.x);
			p_toGet.y = pointStart.y + t*(pointEnd.y - pointStart.y);
			return p_toGet;
		}
	}


	Point pointStart;		// Start of line
	Point pointEnd;			// End of line
};


//Class to hold the matrices of x and y coordinates generated by
//the Domain TFI method
class Grid {
public:
	// Constructor initializes grid with given dimensions
	Grid(int rows, int cols)
	: x(Eigen::MatrixXd::Zero(rows, cols)),
	  y(Eigen::MatrixXd::Zero(rows, cols))
	{ }

	// Getters for the x and y matrices
	const Eigen::MatrixXd& GetX() const { return x; }
	const Eigen::MatrixXd& GetY() const { return y; }

	// Setters for the x and y matrices
	void SetX(const Eigen::MatrixXd& newX) { x = newX; }
	void SetY(const Eigen::MatrixXd& newY) { y = newY; }

	// Access element in the grid
	void SetPoint(int row, int col,
			double xValue, double yValue) {
		x(row, col) = xValue;
		y(row, col) = yValue;
	}

private:
	Eigen::MatrixXd x; // Matrix holding x-coordinates
	Eigen::MatrixXd y; // Matrix holding y-coordinates

protected:
};


class Domain {
public:
	Domain(std::unique_ptr<Curve> bottom, std::unique_ptr<Curve> top, 
			std::unique_ptr<Curve> left, std::unique_ptr<Curve> right,
			int numDivisions)
	: bottom(std::move(bottom)), top(std::move(top)),
	  left(std::move(left)), right(std::move(right)),
	  grid(numDivisions + 1, numDivisions + 1)
	{ }

	// Grid-object generator
	// Generates the grid based on transfinite interpolation (TFI)
	void GenerateGrid() {
		int divisions = grid.GetX().rows() - 1; // `numDivisions` intervals
		for (int i = 0; i <= divisions; ++i) {
			double eta = static_cast<double>(i) / divisions;
			for (int j = 0; j <= divisions; ++j) {
				double xi = static_cast<double>(j) / divisions;

				// Use TFI to compute coordinates
				Point p = TFI(xi, eta);
				grid.SetPoint(i, j, p.x, p.y);
			}
		}
	}


	// Generates an x, y pair based on xi and eta using TFI
	// Based on 'Basic structured grid generation (Farrashkhalvat, Miles) 
	// section 4.3.2
	Point TFI(double xi, double eta) {
		// Use the boundary curves to compute the x, y coordinates
		// 
		auto [xBottom_atXi, yBottom_atXi] = bottom->at(xi);
		auto [xTop_atXi, yTop_atXi] = top->at(xi);
		auto [xRight_atEta, yRight_atEta] = right->at(eta);
		auto [xLeft_atEta, yLeft_atEta] = left->at(eta);
		auto [xBottom_atZero, yBottom_atZero] = bottom->at(0);
		auto [xTop_atZero, yTop_atZero] = top->at(0);
		auto [xBottom_atOne, yBottom_atOne] = bottom->at(1);
		auto [xTop_atOne, yTop_atOne] = top->at(1);

		double x = (1 - xi) * xLeft_atEta + xi * xRight_atEta
				+ (1 - eta) * xBottom_atXi + eta * xTop_atXi
				- (1 - xi) * (1 - eta) * xBottom_atZero
				- (1 - xi) * eta * xTop_atZero
				- (1 - eta) * xi * xBottom_atOne
				- xi * eta * xTop_atOne;

		double y = (1 - xi) * yLeft_atEta + xi * yRight_atEta
				+ (1 - eta) * yBottom_atXi + eta * yTop_atXi
				- (1 - xi) * (1 - eta) * yBottom_atZero
				- (1 - xi) * eta * yTop_atZero
				- (1 - eta) * xi * yBottom_atOne
				- xi * eta * yTop_atOne;

		return Point(x, y);
	}

	// Grid getter
	const Grid& GetGrid() const { return grid; }

private:
	std::unique_ptr <Curve> bottom;
	std::unique_ptr <Curve> top;
	std::unique_ptr <Curve> left;
	std::unique_ptr <Curve> right;
	Grid grid; // Grid that holds x and y coordinates
protected:
};

class EquationCurve:public Curve
{
public:

	virtual~EquationCurve()=default;

	// Compute reparametized curve
	Point at(double t)const override{
		// t -> s_hat
		assert(t <= 1.0);
		assert(t >= 0.0);

/////////////////////
		// double s_1 = 0;
		// double root_old = 0;
		// double root = 0;

		// // Use gamma and gammaprime to compute points
		// // in reparametized curve

		// // Integrate gamma' over 0 to 1  [=/&]
		// auto vecLength = [=](double t){
		// 	Point gammaP = gammaprime(t);
		// 	double l = (double)sqrt(pow(gammaP.x,2) + pow(gammaP.y,2));
		// 	return l;
		// };

		// s_1 = boost::math::quadrature::trapezoidal(vecLength, 0.0, 1.0, MAX_NEWTON_THRESHOLD);

		// // Newton method to find root (t) at which
		// for (uint16_t n = 0; n < MAX_NEWTON_ITER; n++){
		// 	// for loop

		// 	root = (root_old - (boost::math::quadrature::trapezoidal
		// 			(vecLength, 0.0, root_old, MAX_NEWTON_THRESHOLD)) - t * s_1) / (vecLength(root_old));

		// 	// going until convergence (t old = t new)
		// 	if(fabs(root_old - root) < MAX_NEWTON_THRESHOLD)
		// 		break;

		// 	root_old = root;
		// }

		// return gamma(root);
//////////////////

		return gamma(t);

	};

private:
	virtual Point gamma(double t)const = 0;
	virtual Point gammaprime (double t)const = 0;

protected:
	std::function<double(double)> eqFunc;	// Gamma(t) function
};

class BottomCurve : public EquationCurve{

public:

	BottomCurve(std::function<double(double)> func){
		eqFunc = func;;
	}

	// // t -> [0,1]
	// double DomainFunc(double t) const{
	// 	// Describes domain (-10,5)
	// 	double x = (1-t)*(-10) + 5*t;
	// 	return x;
	// }
		// t -> [0,1]
	double x_of_t(double t) const {
		// Describes domain (-10,5)
		double x = (1 - t) * (-10) + 5 * t;
		return x;
	}

	// Point gamma(double t) const override{
	// 	double pointOfInterest = DomainFunc(t);
	// 	// Returns func value parameterized
	// 	Point p_toGet(pointOfInterest, eqFunc(pointOfInterest));
	// 	return p_toGet;
	// };
	Point gamma(double t) const override {
		double x = x_of_t(t);
		// Returns func value parameterized
		Point p_of_t(x, eqFunc(x));
		return p_of_t;
	};

	// Differentiation done through finite difference approximation
	// Point gammaprime(double t) const override{
	// 	double pointOfInterest = DomainFunc(t);
	// 	// Returns differentiated func value
	// 	Point p_toGet(pointOfInterest,((eqFunc(pointOfInterest + DELTAX) -
	// 			eqFunc(pointOfInterest - DELTAX))/(2.0 * DELTAX)));
	// 	return p_toGet;
	// };
	Point gammaprime(double t) const override {
        using namespace boost::math::differentiation;
		// Calculates dP(t)/dt

		// Calculates x-dot. Uses capture variable to access the x_of_t class method
		auto x_dot = finite_difference_derivative(
			[this](double t_val) { return x_of_t(t_val);},
			t);

		// Calculates y-dot.
		auto y_dot = finite_difference_derivative(
			[this](double t_val) {
				double x = x_of_t(t_val);
				return eqFunc(x);
			},
			t);

		return Point(x_dot, y_dot);
	};

private:
};


#endif /* CLASS_DEF_HPP_ */
