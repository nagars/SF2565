/*
 * class_def.hpp
 *
 *  Created on: Nov 12, 2024
 *      Author: Shawn / Alessio
 */

#ifndef CLASS_DEF_HPP_
#define CLASS_DEF_HPP_

#include <cmath>
#include <vector>
#include <memory>
#include <cassert>
#include <limits>

#include "Eigen/Eigen"
#include <boost/math/quadrature/trapezoidal.hpp>
#include <boost/math/tools/roots.hpp>
#include <boost/math/differentiation/finite_difference.hpp>

// #define EPSILON std::numeric_limits<double>::epsilon()
//#define DELTAX std::sqrt(EPSILON)
// #define DELTAX 0.1

// #define MAX_NEWTON_ITER			10000
// #define MAX_NEWTON_THRESHOLD	1e-5

// Holds an x,y point
class Point {
public:
	// Default Constructor
	Point();
	// Parameter Constructor
	Point(const double xCoord, const double yCoord)
	: x(xCoord), y(yCoord){}
	// Coordinate variables
	double x, y;

private:
protected:
};

// Used to represent the bottom curve
class Curve {
public:
	virtual ~Curve() = default;
	virtual Point at(double t) const = 0;
private:
protected:
};

// Used to represent the line boundaries of the top/left/right
class StraightLine : public Curve {

public:
	StraightLine(Point a, Point b):
		pointStart(a), pointEnd(b) { }

	// t = {0,1}. t = 0 -> pointStart. t = 1 -> pointEnd
	Point at(double t) const override {
		// Edge case for vertical line
		if(fabs(pointEnd.x - pointStart.x) < EPSILON) {
			Point p_toGet(pointStart.x,0);	// Init y point as 0 for now
			p_toGet.y = pointStart.y + t*(pointEnd.y - pointStart.y);
			return p_toGet;
		}// Edge case for horizontal line
		else if (fabs(pointEnd.y - pointStart.y) < EPSILON) {

			Point p_toGet(0,pointStart.y);	// Init x point as 0 for now
			p_toGet.x = pointStart.x + t*(pointEnd.x - pointStart.x);
			return p_toGet;
		} else {
			double pointOfInterest = pointStart.x + t*(pointEnd.x - pointStart.x);
			Point p_toGet(pointOfInterest,0);	// Init y point as 0 for now
			// p_toGet.y = pointStart.y + t*(pointEnd.x - pointStart.x);
			p_toGet.y = pointStart.y + t*(pointEnd.y - pointStart.y);
			return p_toGet;
		}
	}

	Point pointStart;		// Start of line
	Point pointEnd;			// End of line

private:
	// Tolerance to check for edge cases of vertical boundaries
	static constexpr double EPSILON = std::numeric_limits<double>::epsilon();

protected:
};


//Class to hold the matrices of x and y coordinates generated by
//the Domain TFI method
class Grid {

public:
	// Constructor initializes grid with given dimensions
	Grid(int rows, int cols)
	: x(Eigen::MatrixXd::Zero(rows, cols)),
	  y(Eigen::MatrixXd::Zero(rows, cols))
	{ }

	// Getters for the x and y matrices
	const Eigen::MatrixXd& GetX() const { return x; }
	const Eigen::MatrixXd& GetY() const { return y; }

	// Setters for the x and y matrices
	void SetX(const Eigen::MatrixXd& newX) { x = newX; }
	void SetY(const Eigen::MatrixXd& newY) { y = newY; }

	// Access element in the grid
	void SetPoint(int row, int col,
			double xValue, double yValue) {
		x(row, col) = xValue;
		y(row, col) = yValue;
	}

private:
	Eigen::MatrixXd x; // Matrix holding x-coordinates
	Eigen::MatrixXd y; // Matrix holding y-coordinates

protected:
};


class Domain {

public:
	Domain(std::unique_ptr<Curve> bottom, std::unique_ptr<Curve> top, 
			std::unique_ptr<Curve> left, std::unique_ptr<Curve> right,
			int numDivisions)
	: bottom(std::move(bottom)), top(std::move(top)),
	  left(std::move(left)), right(std::move(right)),
	  grid(numDivisions + 1, numDivisions + 1)
	{ }

	// Grid-object generator
	// Generates the grid based on transfinite interpolation (TFI)
	void GenerateGrid() {
		int divisions = grid.GetX().rows() - 1; // `numDivisions` intervals
		for (int i = 0; i <= divisions; ++i) {
			double eta = static_cast<double>(i) / divisions;
			for (int j = 0; j <= divisions; ++j) {
				double xi = static_cast<double>(j) / divisions;

				// Use TFI to compute coordinates
				Point p = TFI(xi, eta);
				grid.SetPoint(i, j, p.x, p.y);
			}
		}
	}

	// Generates an x, y pair based on xi and eta using TFI
	// Based on 'Basic structured grid generation (Farrashkhalvat, Miles) 
	// section 4.3.2
	Point TFI(double xi, double eta) {
		// Use the boundary curves to compute the x, y coordinates
		// 
		auto [xBottom_atXi, yBottom_atXi] = bottom->at(xi);
		auto [xTop_atXi, yTop_atXi] = top->at(xi);
		auto [xRight_atEta, yRight_atEta] = right->at(eta);
		auto [xLeft_atEta, yLeft_atEta] = left->at(eta);
		auto [xBottom_atZero, yBottom_atZero] = bottom->at(0);
		auto [xTop_atZero, yTop_atZero] = top->at(0);
		auto [xBottom_atOne, yBottom_atOne] = bottom->at(1);
		auto [xTop_atOne, yTop_atOne] = top->at(1);

		double x = (1 - xi) * xLeft_atEta + xi * xRight_atEta
				+ (1 - eta) * xBottom_atXi + eta * xTop_atXi
				- (1 - xi) * (1 - eta) * xBottom_atZero
				- (1 - xi) * eta * xTop_atZero
				- (1 - eta) * xi * xBottom_atOne
				- xi * eta * xTop_atOne;

		double y = (1 - xi) * yLeft_atEta + xi * yRight_atEta
				+ (1 - eta) * yBottom_atXi + eta * yTop_atXi
				- (1 - xi) * (1 - eta) * yBottom_atZero
				- (1 - xi) * eta * yTop_atZero
				- (1 - eta) * xi * yBottom_atOne
				- xi * eta * yTop_atOne;

		return Point(x, y);
	}

	// Grid getter
	const Grid& GetGrid() const { return grid; }

private:
	std::unique_ptr <Curve> bottom;
	std::unique_ptr <Curve> top;
	std::unique_ptr <Curve> left;
	std::unique_ptr <Curve> right;
	Grid grid; // Grid that holds x and y coordinates

protected:
};


class EquationCurve:public Curve {

public:
	virtual~EquationCurve()=default;

	// Compute reparametized curve
	Point at(double t) const override {

		double hatS = t; // rename to keep same signature as Curve class
		double arcLengthTotal = arcLength(1.0); // full curve length
		double arcLengthTarget = hatS * arcLengthTotal; // Target arc-length value

        // Define the function f(t) = s(t) - sTarget
        auto f = [this, arcLengthTarget](double t) -> double {
            return arcLength(t) - arcLengthTarget;
        };

        // Define the function f'(t) = |dP/dt|
        auto f_prime = [this](double t) -> double {
            Point Pdot = this->gammaprime(t);
            return std::sqrt(Pdot.x * Pdot.x + Pdot.y * Pdot.y);
        };

        // Use Newton's method from Boost
		using namespace boost::math::tools;
        uintmax_t max_iter = 50;
        double t_of_hatS = newton_raphson_iterate(
            [&f, &f_prime](double t) { return std::make_pair(f(t), f_prime(t)); },
            0.5,  // Initial guess (t = 0.5, middle of computational domain)
            0.0,  // Lower bound of t
            1.0,  // Upper bound of t
            TOL,  // Use defined tolerance
            max_iter
        );

        if (max_iter == 0) {
            throw std::runtime_error("Newton's method didn't converge");
        };

		// return something to clear syntax errors
		return this->gamma(t_of_hatS);
	};

private:
	virtual Point gamma(double t) const = 0;
	virtual Point gammaprime (double t) const = 0;

	static constexpr double TOL = 1e-6; // Tolerance for numerical calculations

	// Compute arc-length function s(t) using boost numerical integration
    double arcLength(double t) const {
        using namespace boost::math::quadrature;

        // Define the integrand for arc-length calculation
        auto normPdot = [this](double tau) -> double {
            Point Pdot = this->gammaprime(tau);
            return std::sqrt(Pdot.x * Pdot.x + Pdot.y * Pdot.y);
        };

        // Perform numerical integration over [0, t]
        return trapezoidal(normPdot, 0.0, t, TOL);
    }

protected:
	std::function<double(double)> eqFunc;
};


class BottomCurve : public EquationCurve {

public:
	BottomCurve(std::function<double(double)> func) {
		eqFunc = func;;
	}

	double x_of_t(double t) const {
		// Describes domain (-10,5)
		double x = (1 - t) * (-10) + 5 * t;
		return x;
	}

	// Returns P(t)
	Point gamma(double t) const override {
		double x = x_of_t(t);
		Point p_of_t(x, eqFunc(x));
		return p_of_t;
	};

	// Calculates dP(t)/dt using finite differences
	Point gammaprime(double t) const override {
        using namespace boost::math::differentiation;

		// Calculates x-dot. Uses capture variable to access the x_of_t class method
		auto x_dot = finite_difference_derivative(
			[this](double t_val) { return x_of_t(t_val);},
			t);

		// Calculates y-dot.
		auto y_dot = finite_difference_derivative(
			[this](double t_val) {
				double x = x_of_t(t_val);
				return eqFunc(x);
			},
			t);

		return Point(x_dot, y_dot);
	};

private:
};


#endif /* CLASS_DEF_HPP_ */